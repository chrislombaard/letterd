name: Cron Tick
on:
  schedule:
    - cron: "0 * * * *" # hourly, UTC
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: cron-tick
  cancel-in-progress: false

jobs:
  tick:
    name: Hit /api/cron/tick
    runs-on: ubuntu-latest
    timeout-minutes: 2
    env:
      ENDPOINT: ${{ secrets.CRON_ENDPOINT }}
      CRON_SECRET: ${{ secrets.CRON_SECRET }}
      VERCEL_BYPASS_TOKEN: ${{ secrets.VERCEL_BYPASS_TOKEN }}
    steps:
      - name: Call endpoint
        run: |
          set -euo pipefail

          if [[ -z "${ENDPOINT:-}" || -z "${CRON_SECRET:-}" || -z "${VERCEL_BYPASS_TOKEN:-}" ]]; then
            echo "Missing ENDPOINT/CRON_SECRET/VERCEL_BYPASS_TOKEN"; exit 2
          fi

          # Build URL (handles endpoints that may already include a query string)
          if [[ "$ENDPOINT" == *\?* ]]; then
            URL="${ENDPOINT}&secret=${CRON_SECRET}"
          else
            URL="${ENDPOINT}?secret=${CRON_SECRET}"
          fi

          attempt=0
          until [[ $attempt -ge 3 ]]; do
            attempt=$((attempt+1))

            resp="$(curl -sS -L \
              -H "x-vercel-protection-bypass: ${VERCEL_BYPASS_TOKEN}" \
              --max-time 20 \
              -w '\n%{http_code}' \
              "$URL" || true)"

            status="$(printf '%s' "$resp" | tail -n1)"
            body="$(printf  '%s' "$resp" | sed '$d')"

            if [[ "$status" -ge 200 && "$status" -lt 300 ]]; then
              echo "Status: $status"
              echo "Body: $body"
              exit 0
            fi

            sleep 5
          done

          echo "Non-2xx after $attempt attempts: $status"
          echo "Body: $body"
          exit 1
